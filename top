`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 12/05/2024 08:56:36 PM
// Design Name: 
// Module Name: top
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module top(
    input clk,
    input reset,
    input wire up,  // User input
    input wire down,
    input wire left,
    input wire right,
    output hsync,
    output vsync,
    output reg game_over,
    output reg [3:0] red, green, blue, // VGA signals
    output [6:0] seg,
    output [3:0] an
    );
    
    // VGA Connections
    wire [9:0] x, y;
    wire video_on;
    
    // Game Connections
    wire [1:0] direction;
    wire food_on, snake_on, collision;
    wire food_eaten;
    wire [9:0] food_x, food_y;
    wire [13:0] score;
    
    wire clk_10Hz;
    slow_clock #(10000000) (
        .clk_in(clk),
        .clk_out(clk_10Hz)
        );
        
    // VGA controller
    vga_controller vga (
        .clk(clk),
        .reset(reset),
        .hsync(hsync),
        .vsync(vsync),
        .video_on(video_on),
        .x(x),
        .y(y)
    );

    // Direction control
    reg [1:0] current_direction;
    wire [1:0] new_direction;

    button_to_direction dir_ctrl (
        .clk(clk),
        .reset(reset),
        .btn_up(up),
        .btn_down(down),
        .btn_left(left),
        .btn_right(right),
        .current_direction(current_direction),
        .new_direction(new_direction)
    );
    
    // Update the direction at every clock cycle
    always @(posedge clk or posedge reset) begin
        if (reset) current_direction <= 2'b01; // Default direction: right
        else current_direction <= new_direction;
    end
    
    // Snake logic
    wire [9:0] head_x, head_y;
    wire [49:0] body_x, body_y;
    wire [4:0] snake_length;
    snake_logic snake (
        .clk(clk_10Hz),
        .reset(reset),
        .direction(current_direction),
        .food_eaten(food_eaten),
        .head_x(head_x),
        .head_y(head_y),
        .snake_length(snake_length),
        .body_x(body_x),
        .body_y(body_y)
    );
    
    food_logic food(
        .clk(clk_10Hz),
        .reset(reset),
        .head_x(head_x),
        .head_y(head_y),
        .food_eaten(food_eaten),
        .score(score),
        .food_x(food_x),
        .food_y(food_y)
    );

    collision_detection collision_mod (
         .head_x(head_x), 
         .head_y(head_y),
         .body_x(body_x),
         .body_y(body_y),
         .snake_length(snake_length),
         .collision(collision)
    );
    
    // Snake renderer
    snake_renderer snake_rend (
        .pixel_x(x),
        .pixel_y(y),
        .head_x(head_x),
        .head_y(head_y),
        .body_x(body_x),
        .body_y(body_y),
        .snake_length(snake_length),
        .pixel_on(snake_on)
    );
    
    food_renderer food_rend (
        .pixel_x(x),  
        .pixel_y(y),  
        .food_x(food_x),   
        .food_y(food_y),   
        .food_on(food_on)    
    );

    always @* begin
        if (collision) begin
           game_over = 1; 
        end
    end
     
    always @*
        if (~video_on) begin
            red   = 4'b0000;
            green = 4'b0000;
            blue  = 4'b0000;// Clear the screen on reset
        end else begin
            if (snake_on) begin
                red   <= 4'b0000;  
                green <= 4'b1111;
                blue  <= 4'b0000;
            end
            else if (food_on) begin
                red   <= 4'b1111;  
                green <= 4'b0000;
                blue  <= 4'b0000;
            end
            else begin        
                red   <= 4'b1111;  
                green <= 4'b1111;
                blue  <= 4'b1111;
            end
        end
        
endmodule
