`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 11/12/2024 06:29:06 PM
// Design Name: 
// Module Name: gameLogic
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module gameLogic(
    input clk, reset,
    input wire up, down, left, right, // 5 button inputs
    output reg [1:0] direction,  // 2-bit input for direction (00: Up, 01: Down, 10: Left, 11: Right)
    output reg [4:0] snakeLength,
    output reg [9:0] snakeX [31:0], snakeY [31:0], // Index 0 indicates head
    output reg [9:0] foodX, foodY,
    output reg gameOver // Game Over = 1
    );
    
    parameter UP = 2'b00, DOWN = 2'b01, LEFT = 2'b10, RIGHT = 2'b11;
    integer x, y;
    // MAX DISTANCE
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            direction <= UP; // Initial direction set to UP  
        //update current direction based on input
        end else begin
            if (up && direction != DOWN) // Prevent moving down while going up
                direction <= UP;
            else if (down && direction != UP)
                direction <= DOWN;
            else if (left && direction != RIGHT)
                direction <= LEFT;
            else if (right && direction != LEFT)
                direction <= RIGHT;
        end
        
        //increment each body segment by 1 (overlap with head)
        for(x = 1; x < snakeLength - 1; x = x + 1) begin
            snakeX[x] <= snakeX[x-1];
            snakeY[x] <= snakeY[x-1];
        
        end
        
        //update head position based on current direction
        case(direction)
            UP:     snakeY[0] <= snakeY[0] + 1;
            DOWN:   snakeY[0] <= snakeY[0] - 1;
            LEFT:   snakeX[0] <= snakeX[0] - 1;
            RIGHT:  snakeX[0] <= snakeX[0] + 1;
        endcase
        
        //detect head collision with wall
        if(snakeX[0] < 0 || snakeX[0] > 640 || snakeY[0] < 0 || snakeY[0] < 480) begin
            gameOver <= 1;
        
        end
        //detect collision with self
        
        for (x = 0; x < 32; x = x + 1) begin
            for (y = 0; y < 32; y = x + 1) begin
                if ((snakeX[x] == x) & (snakeY[y] == y))
                    gameOver <= 1;
            end
        end
        //detect food
         if ((foodX == snakeX[0]) & (foodY == snakeY[0])) begin        //if food
            snakeLength <= snakeLength + 1;        // Increase snake length by 1
            // Clear food by generating a new x and y randomly
        
            foodX = $random % 640;
            foodY = $random % 480;


        end
    end          
endmodule
