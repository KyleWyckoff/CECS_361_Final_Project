`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 11/12/2024 06:29:06 PM
// Design Name: 
// Module Name: gameLogic
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module gameLogic(
    input clk, reset,
    input wire up, down, left, right, // 5 button inputs
    output reg [1:0] direction,  // 2-bit input for direction (00: Up, 01: Down, 10: Left, 11: Right)
    output reg [4:0] snakeLength,
    output reg [9:0] snake_x [31:0], snake_y [31:0], // Index 0 indicates head
    output reg [9:0] food_x, food_y,
    output reg game_over // Game Over = 1
    );
    
    parameter UP = 2'b00, DOWN = 2'b01, LEFT = 2'b10, RIGHT = 2'b11;
    integer x, y;
    // MAX DISTANCE
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            direction <= UP; // Initial direction set to UP  
        //update current direction based on input
        end else begin
            if (up && direction != DOWN) // Prevent moving down while going up
                direction <= UP;
            else if (down && direction != UP)
                direction <= DOWN;
            else if (left && direction != RIGHT)
                direction <= LEFT;
            else if (right && direction != LEFT)
                direction <= RIGHT;
        end
        
        //increment each body segment by 1 (overlap with head)
        if ((food_x == snake_x[0]) & (food_y == snake_y[0])) begin
            // Increase snake length by 1
            snakeLength <= snakeLength + 1;
            
            // Clear food
        end
        
        
        //update head position based on current direction
//        case(direction)
//            UP:     snake_y <= snake_y + 1;
//            DOWN:   snake_y <= snake_y - 1;
//            LEFT:   snake_x <= snake_x - 1;
//            RIGHT:  snake_x <= snake_x + 1;
//        endcase
        
        
        //detect collision with wall or self
        
        for (x = 0; x < 32; x = x + 1) begin
            for (y = 0; y < 32; y = x + 1) begin
                if ((snake_x == x) & (snake_y == y))
                    game_over <= 1;
            end
        end
        //detect food
            //if food
    end            //clear food
endmodule
